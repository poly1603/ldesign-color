/*!
 * ***********************************
 * @ldesign/color v1.0.0           *
 * Built with rollup               *
 * Build time: 2024-10-21 14:32:31 *
 * Build mode: production          *
 * Minified: No                    *
 * ***********************************
 */import{Color as b}from"../core/Color.js";let C=null,M=null;function D(){return(!C||!M)&&(C=document.createElement("canvas"),M=C.getContext("2d")),{canvas:C,ctx:M}}const w=[],R=50;function y(f){return w.length>0?(w.pop(),b.fromRGB(f.r,f.g,f.b)):b.fromRGB(f.r,f.g,f.b)}function x(f){w.length<R&&w.push(f)}typeof window<"u"&&window.addEventListener("unload",()=>{w.length=0,C=null,M=null});class p{static async extractPalette(e,r=5,n={}){const t=await this.getImagePixels(e,n);return this.kMeansClustering(t,r,n).sort((o,s)=>s.weight-o.weight).map(o=>o.center)}static async findDominantColors(e,r=3,n={}){const t=await this.getImagePixels(e,n),o=new Map;for(const a of t){const i=y(a),u=this.getColorKey(i,n.threshold||10);o.set(u,(o.get(u)||0)+1),x(i)}const s=t.length,c=[];for(const[a,i]of o.entries()){const[u,h,g]=a.split(",").map(Number),l=b.fromRGB(u,h,g),d=i/s*100,m=this.calculateProminence(l,d);c.push({color:l,count:i,percentage:d,prominence:m})}return c.sort((a,i)=>i.prominence-a.prominence).slice(0,r)}static async analyzeColorDistribution(e,r={}){const n=await this.getImagePixels(e,r),t=Array.from({length:360},()=>0),o=Array.from({length:101},()=>0),s=Array.from({length:101},()=>0);let c=0,a=0;for(const l of n){const d=y(l),m=d.toHSL();t[Math.round(m.h)]++,o[Math.round(m.s)]++,s[Math.round(m.l)]++,c+=m.s,a+=m.l,x(d)}const i=Math.max(...t),u=Math.max(...o),h=Math.max(...s);for(let l=0;l<360;l++)t[l]=t[l]/i;for(let l=0;l<101;l++)o[l]=o[l]/u,s[l]=s[l]/h;const g=this.findPeaks(t,3);return{hueDistribution:t,saturationDistribution:o,lightnessDistribution:s,dominantHues:g,averageSaturation:c/n.length,averageLightness:a/n.length}}static async getImagePixels(e,r={}){const n=await this.loadImage(e),{canvas:t,ctx:o}=D(),s=r.quality||5,c=r.sampleSize||Math.max(10,100-s*10);t.width=Math.min(n.width,c),t.height=Math.min(n.height,c),o.drawImage(n,0,0,t.width,t.height);const a=o.getImageData(0,0,t.width,t.height),i=[],u=a.data;for(let h=0,g=u.length;h<g;h+=4){if(u[h+3]<128)continue;const l=u[h],d=u[h+1],m=u[h+2];r.ignoreWhite&&l>240&&d>240&&m>240||r.ignoreBlack&&l<15&&d<15&&m<15||i.push({r:l,g:d,b:m})}return o.clearRect(0,0,t.width,t.height),i}static async loadImage(e){if(e instanceof HTMLImageElement)return e;const r=new Image;if(r.crossOrigin="anonymous",typeof e=="string")r.src=e;else{const n=URL.createObjectURL(e);r.src=n,r.onload=()=>URL.revokeObjectURL(n)}return new Promise((n,t)=>{r.onload=()=>n(r),r.onerror=t})}static kMeansClustering(e,r,n={}){if(e.length===0)return[];if(r>=e.length)return e.map(a=>({center:new b(a),members:[a],weight:1}));const t=this.initializeCenters(e,r).map(a=>({center:a,members:[],weight:0})),o=30;let s=0,c=!0;for(;c&&s<o;){c=!1,t.forEach(a=>a.members=[]);for(const a of e){const i=y(a);let u=1/0,h=0;for(let g=0;g<t.length;g++){const l=this.colorDistance(i,t[g].center);l<u&&(u=l,h=g)}t[h].members.push(a),x(i)}for(const a of t)if(a.members.length>0){const i=this.calculateCentroid(a.members);this.colorDistance(i,a.center)>1&&(a.center=i,c=!0),a.weight=a.members.length/e.length}s++}return t.filter(a=>a.members.length>0)}static initializeCenters(e,r){const n=[],t=e[Math.floor(Math.random()*e.length)];n.push(new b(t));for(let o=1;o<r;o++){const s=e.map(i=>{const u=y(i);let h=1/0;for(const g of n){const l=this.colorDistance(u,g);l<h&&(h=l)}return x(u),h}),c=s.reduce((i,u)=>i+u,0);let a=Math.random()*c;for(let i=0;i<e.length;i++)if(a-=s[i],a<=0){n.push(new b(e[i]));break}}return n}static calculateCentroid(e){if(e.length===0)return new b("#000000");let r=0,n=0,t=0;for(const s of e)r+=s.r,n+=s.g,t+=s.b;const o=e.length;return b.fromRGB(Math.round(r/o),Math.round(n/o),Math.round(t/o))}static colorDistance(e,r){const n=e.toRGB(),t=r.toRGB(),o=(n.r+t.r)/2,s=n.r-t.r,c=n.g-t.g,a=n.b-t.b,i=2+o/256,u=4,h=2+(255-o)/256;return Math.sqrt(i*s*s+u*c*c+h*a*a)}static getColorKey(e,r){const n=e.toRGB(),t=Math.max(1,r),o=Math.round(n.r/t)*t,s=Math.round(n.g/t)*t,c=Math.round(n.b/t)*t;return`${o},${s},${c}`}static calculateProminence(e,r){const n=e.toHSL(),t=n.s/100,o=1-Math.abs(n.l-50)/50;return r*t*o}static findPeaks(e,r){const n=[];for(let t=1;t<e.length-1;t++)e[t]>e[t-1]&&e[t]>e[t+1]&&n.push({index:t,value:e[t]});return n.sort((t,o)=>o.value-t.value).slice(0,r).map(t=>t.index)}static async generateColorReport(e,r={}){const[n,t,o]=await Promise.all([this.extractPalette(e,5,r),this.findDominantColors(e,3,r),this.analyzeColorDistribution(e,r)]),s=this.analyzeMood(n),c=this.analyzeTemperature(o.dominantHues);return{palette:n,dominant:t,distribution:o,mood:s,temperature:c}}static analyzeMood(e){let r=0,n=0;for(const s of e){const c=s.toHSL();r+=c.s,n+=c.l}const t=r/e.length,o=n/e.length;return t>70&&o>50?"\u5A32\u8BF2\u59CF\u934F\u546E\u77DD":t<30&&o>70?"\u5A13\u546E\u67CA\u5A23\uFFE0\u6CE4":o<30?"\u5A23\u8FA8\u77C7\u7EC1\u70B5\uE75D":t>60?"\u9411\uE15F\u510F\u6FC2\u65C0\u6581":"\u9A9E\u51B2\u62F0\u9477\uE046\u52A7"}static analyzeTemperature(e){if(e.length===0)return"neutral";let r=0,n=0;for(const t of e)t>=0&&t<=60||t>=300&&t<=360?r++:t>=120&&t<=240&&n++;return r>n?"warm":n>r?"cool":"neutral"}}const P=p.extractPalette.bind(p),E=p.findDominantColors.bind(p),z=p.analyzeColorDistribution.bind(p),A=p.generateColorReport.bind(p);/*! End of @ldesign/color | Powered by @ldesign/builder */export{p as ColorAnalyzer,z as analyzeColorDistribution,P as extractPalette,E as findDominantColors,A as generateColorReport};
//# sourceMappingURL=index.js.map
