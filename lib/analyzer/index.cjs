"use strict";/*!
 * ***********************************
 * @ldesign/color v1.0.0           *
 * Built with rollup               *
 * Build time: 2024-10-21 14:32:31 *
 * Build mode: production          *
 * Minified: No                    *
 * ***********************************
 */var b=require("../core/Color.cjs");let p=null,M=null;function x(){return(!p||!M)&&(p=document.createElement("canvas"),M=p.getContext("2d")),{canvas:p,ctx:M}}const w=[],R=50;function y(f){return w.length>0&&w.pop(),b.Color.fromRGB(f.r,f.g,f.b)}function D(f){w.length<R&&w.push(f)}typeof window<"u"&&window.addEventListener("unload",()=>{w.length=0,p=null,M=null});class C{static async extractPalette(e,r=5,n={}){const t=await this.getImagePixels(e,n);return this.kMeansClustering(t,r,n).sort((o,i)=>i.weight-o.weight).map(o=>o.center)}static async findDominantColors(e,r=3,n={}){const t=await this.getImagePixels(e,n),o=new Map;for(const a of t){const s=y(a),u=this.getColorKey(s,n.threshold||10);o.set(u,(o.get(u)||0)+1),D(s)}const i=t.length,c=[];for(const[a,s]of o.entries()){const[u,h,g]=a.split(",").map(Number),l=b.Color.fromRGB(u,h,g),d=s/i*100,m=this.calculateProminence(l,d);c.push({color:l,count:s,percentage:d,prominence:m})}return c.sort((a,s)=>s.prominence-a.prominence).slice(0,r)}static async analyzeColorDistribution(e,r={}){const n=await this.getImagePixels(e,r),t=Array.from({length:360},()=>0),o=Array.from({length:101},()=>0),i=Array.from({length:101},()=>0);let c=0,a=0;for(const l of n){const d=y(l),m=d.toHSL();t[Math.round(m.h)]++,o[Math.round(m.s)]++,i[Math.round(m.l)]++,c+=m.s,a+=m.l,D(d)}const s=Math.max(...t),u=Math.max(...o),h=Math.max(...i);for(let l=0;l<360;l++)t[l]=t[l]/s;for(let l=0;l<101;l++)o[l]=o[l]/u,i[l]=i[l]/h;const g=this.findPeaks(t,3);return{hueDistribution:t,saturationDistribution:o,lightnessDistribution:i,dominantHues:g,averageSaturation:c/n.length,averageLightness:a/n.length}}static async getImagePixels(e,r={}){const n=await this.loadImage(e),{canvas:t,ctx:o}=x(),i=r.quality||5,c=r.sampleSize||Math.max(10,100-i*10);t.width=Math.min(n.width,c),t.height=Math.min(n.height,c),o.drawImage(n,0,0,t.width,t.height);const a=o.getImageData(0,0,t.width,t.height),s=[],u=a.data;for(let h=0,g=u.length;h<g;h+=4){if(u[h+3]<128)continue;const l=u[h],d=u[h+1],m=u[h+2];r.ignoreWhite&&l>240&&d>240&&m>240||r.ignoreBlack&&l<15&&d<15&&m<15||s.push({r:l,g:d,b:m})}return o.clearRect(0,0,t.width,t.height),s}static async loadImage(e){if(e instanceof HTMLImageElement)return e;const r=new Image;if(r.crossOrigin="anonymous",typeof e=="string")r.src=e;else{const n=URL.createObjectURL(e);r.src=n,r.onload=()=>URL.revokeObjectURL(n)}return new Promise((n,t)=>{r.onload=()=>n(r),r.onerror=t})}static kMeansClustering(e,r,n={}){if(e.length===0)return[];if(r>=e.length)return e.map(a=>({center:new b.Color(a),members:[a],weight:1}));const t=this.initializeCenters(e,r).map(a=>({center:a,members:[],weight:0})),o=30;let i=0,c=!0;for(;c&&i<o;){c=!1,t.forEach(a=>a.members=[]);for(const a of e){const s=y(a);let u=1/0,h=0;for(let g=0;g<t.length;g++){const l=this.colorDistance(s,t[g].center);l<u&&(u=l,h=g)}t[h].members.push(a),D(s)}for(const a of t)if(a.members.length>0){const s=this.calculateCentroid(a.members);this.colorDistance(s,a.center)>1&&(a.center=s,c=!0),a.weight=a.members.length/e.length}i++}return t.filter(a=>a.members.length>0)}static initializeCenters(e,r){const n=[],t=e[Math.floor(Math.random()*e.length)];n.push(new b.Color(t));for(let o=1;o<r;o++){const i=e.map(s=>{const u=y(s);let h=1/0;for(const g of n){const l=this.colorDistance(u,g);l<h&&(h=l)}return D(u),h}),c=i.reduce((s,u)=>s+u,0);let a=Math.random()*c;for(let s=0;s<e.length;s++)if(a-=i[s],a<=0){n.push(new b.Color(e[s]));break}}return n}static calculateCentroid(e){if(e.length===0)return new b.Color("#000000");let r=0,n=0,t=0;for(const i of e)r+=i.r,n+=i.g,t+=i.b;const o=e.length;return b.Color.fromRGB(Math.round(r/o),Math.round(n/o),Math.round(t/o))}static colorDistance(e,r){const n=e.toRGB(),t=r.toRGB(),o=(n.r+t.r)/2,i=n.r-t.r,c=n.g-t.g,a=n.b-t.b,s=2+o/256,u=4,h=2+(255-o)/256;return Math.sqrt(s*i*i+u*c*c+h*a*a)}static getColorKey(e,r){const n=e.toRGB(),t=Math.max(1,r),o=Math.round(n.r/t)*t,i=Math.round(n.g/t)*t,c=Math.round(n.b/t)*t;return`${o},${i},${c}`}static calculateProminence(e,r){const n=e.toHSL(),t=n.s/100,o=1-Math.abs(n.l-50)/50;return r*t*o}static findPeaks(e,r){const n=[];for(let t=1;t<e.length-1;t++)e[t]>e[t-1]&&e[t]>e[t+1]&&n.push({index:t,value:e[t]});return n.sort((t,o)=>o.value-t.value).slice(0,r).map(t=>t.index)}static async generateColorReport(e,r={}){const[n,t,o]=await Promise.all([this.extractPalette(e,5,r),this.findDominantColors(e,3,r),this.analyzeColorDistribution(e,r)]),i=this.analyzeMood(n),c=this.analyzeTemperature(o.dominantHues);return{palette:n,dominant:t,distribution:o,mood:i,temperature:c}}static analyzeMood(e){let r=0,n=0;for(const i of e){const c=i.toHSL();r+=c.s,n+=c.l}const t=r/e.length,o=n/e.length;return t>70&&o>50?"\u5A32\u8BF2\u59CF\u934F\u546E\u77DD":t<30&&o>70?"\u5A13\u546E\u67CA\u5A23\uFFE0\u6CE4":o<30?"\u5A23\u8FA8\u77C7\u7EC1\u70B5\uE75D":t>60?"\u9411\uE15F\u510F\u6FC2\u65C0\u6581":"\u9A9E\u51B2\u62F0\u9477\uE046\u52A7"}static analyzeTemperature(e){if(e.length===0)return"neutral";let r=0,n=0;for(const t of e)t>=0&&t<=60||t>=300&&t<=360?r++:t>=120&&t<=240&&n++;return r>n?"warm":n>r?"cool":"neutral"}}const P=C.extractPalette.bind(C),z=C.findDominantColors.bind(C),A=C.analyzeColorDistribution.bind(C),E=C.generateColorReport.bind(C);exports.ColorAnalyzer=C,exports.analyzeColorDistribution=A,exports.extractPalette=P,exports.findDominantColors=z,exports.generateColorReport=E;/*! End of @ldesign/color | Powered by @ldesign/builder */
//# sourceMappingURL=index.cjs.map
